# 도메인 모델과 바운디드 컨텍스트

## 9.1 도메인 모델과 경계

처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.
한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

예를 들어 상품이라는 모델은 카탈로그에서 상품, 재고 관리에서 상품, 주문에서 상품, 배송에서 상품 등 이름만 같지 실제로 의미하는 것은 다르다.

이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.

## 9.2 바운디드 컨텍스트

`바운디드 컨텍스트`는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다. 바운디드 컨텍스트는 용어를 기준으로 구분한다. 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다. 또한 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다. 이때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다.

이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

![9 3](https://user-images.githubusercontent.com/66859363/209642066-8c856808-b95d-488b-b8dd-6bb2139e78b5.png)

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함한다. 같은 사용자라 하더라도 주문 바운디드 컨텍스트와 회원 바운디드 컨텍스트가 갖는 모델이 달라진다.

![9 4](https://user-images.githubusercontent.com/66859363/209642070-ed95d7db-ad2a-42ee-a3bd-6e9ebf6d42bf.png)

## 9.3 바운디드 컨텍스트 구현

바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다. 바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영역을 모두 포함한다.

![9 5](https://user-images.githubusercontent.com/66859363/209642072-e6fdaddf-c1c1-4c01-8c4b-a21dbf9b591b.png)

모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.

예를 들어 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다.

![9 6](https://user-images.githubusercontent.com/66859363/209642073-f3bfb745-c537-4ec7-9fbd-8da2e849d397.png)

또한 한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수도 있다. 대표적인 예가 `CQRS 패턴(Command Query Responsibility Segregation)`이다.

> CQRS 패턴은 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴이다.

![9 7](https://user-images.githubusercontent.com/66859363/209642075-bb590eeb-4c1e-4f98-ab4f-863309a2757a.png)

## 9.4 바운디드 컨텍스트 간 통합

만약 온라인 쇼핑 사이트에서 카탈로그 하위 도메인에 개인화 추천 기능을 도입하기로 했다고 하자. 기존 카탈로그 시스템을 개발하던 팀과 별도로 추천 시스템을 담당하는 팀이 새로 생겨 주도적으로 추천 시스템을 만기로도 했다면 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.

두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.

바운디드 컨텍스트 간 통합을 하는 방법에는 일반적으로 두 가지가 있다.

+ REST API 호출을 통한 직접 통합 방식
+ 메시지 큐를 사용하는 간접 통합 방식

### REST API 호출을 통한 직접 통합

![9 11](https://user-images.githubusercontent.com/66859363/209645734-e48b245d-9453-4c11-a8c4-bd2d1869c84a.png)

RecSystemClient를 통해 추천 시스템으로부터 json 형태로 데이터를 제공받는다. 이때 추천 시스템이 제공하는 데이터는 추천 시스템의 모델을 기반으로 하고 있기 때문에 카탈로그 도메인 모델과 일치하지 않는 데이터를 제공할 것이다.

이 데이터들을 카탈로그 도메인에 맞는 상품 모델로 변환하여 사용한다.

### 메시지 큐를 사용하는 간접 통합 방식

![9 13](https://user-images.githubusercontent.com/66859363/209645741-de71eaa1-a5f8-4dd4-a772-ed16d477ff40.png)

카탈로그 바운디드 컨텍스트는 추천 시스템이 필요로 하는 사용자 활동 이력을 메시지 큐에 추가한다. 메시지 큐는 비동기로 처리하기 때문에 카탈로그 바운디드 컨텍스트는 메시지를 큐에 추가한 뒤에 추천 바운디드 컨텍스트가 메시지를 처리할 때까지 기다리지 않고 이어서 자신의 처리를 계속한다.

추천 바운디드는 큐에서 이력 메시지를 읽어와 추천을 계산하는 데 사용할 것이다.

이는 즉, 두 바운디드 컨텍스트가 사용할 메시지의 데이터 구조를 맞춰야 함을 의미한다.

두 바운디드 컨텍스트를 개발하는 팀은 메시징 큐에 담을 데이터의 구조를 협의하게 되는데 그 큐를 누가 제공하느냐에 따라 데이터 구조가 결정된다. 예를 들어 카탈로그 시스템에서 큐를 제공한다면 큐에 담기는 내용은 카탈로그 도메인을 따른다.

![9 16](https://user-images.githubusercontent.com/66859363/209645743-630a4e9c-f489-448c-b542-11cb870c983f.png)

## 9.5 바운디드 컨텍스트 간 관계

바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다. 두 바운디드 컨텍스트가 관계를 맺는 방식에는 세 가지가 있다.

+ 공개 호스트 서비스
+ 공유 커널
+ 독립 방식

### 공개 호스트 서비스

하류 컴포넌트가 상류 컴포넌트에서 제공하는 데이터와 기능에 의존하는 방식이다. `REST API`를 제공하거나 `프로토콜 버퍼`와 같은 것을 이용해서 서비스를 제공할 수 있다.

> 상류 컴포넌트는 일종의 서비스 공급자 역할을 하며 하류 컴포넌트는 그 서비스를 사용하는 고객 역할을 한다. 고객과 공급자 관계에 있는 두 팀은 상호 협력이 필수적이다. 공급자를 하는 상류 팀이 마음대로 API를 변경하면 하류 팀은 변경된 API를 맞추느라 우선순위가 높은 다른 기능을 개발하지 못할 수도 있다. 반대로 상류 팀이 무언가를 변경할 때마다 하류 팀으로부터 여러 절차를 거쳐 승낙을 받아야 한다면 상류 팀은 새로운 개발 시도 자체를 하지 않을 수도 있다. 따라서 상류 팀과 하류 팀은 개발 계획을 서로 공유하고 일정을 협의해야 한다.

상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.

상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다. 따라서 하류 컴포턴트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해 주는 완충 지대를 만들어야 한다. 이를 `안터코럽션 계층`이라 한다.

### 공유 커널

두 바운디드 컨텍스트가 같은 모델을 공유하는 방식이다. 두 바운디드 컨텍스트가 같은 모델을 공유함으로써 중복 설계를 막을 수 있다.

하지만 두 바운디드 컨텍스트가 한 모델을 공유하기 때문에 한 쪽에서 임의로 모델을 변경하면 안 되며 밀접한 관계를 유지해야한다. 밀접한 관계를 형성할 수 없다면 공유 커널을 사용할 떄의 장점보다 공유 커널로 인해 개발이 지연되고 정체되는 문제가 커지게 된다.

### 독립 방식


서로 통합하지 않는 방식이다. 두 바운디드 컨텍스트 간에 통합하지 않으므로 서로 독립적으로 모델을 발전시킨다.

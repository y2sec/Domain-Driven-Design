# 애그리거트 트랜잭션 관리

## 애그리거트의 트랜잭션
![8 1](https://user-images.githubusercontent.com/66859363/208287845-ae039429-15cc-4f61-91f0-d24895bc547a.png)

위와 같은 상황이 발생하면 어떻게 될까?

두 스레드는 가각 트랜잭션을 커밋할 때 수정한 내용을 DB에 반영한다.

이 시점에 배송 상태로 바뀌고 배송지 정보도 바뀌게 된다.
이 순서의 문제점은 운영자는 기존 배송지 정보를 이용하여 배송 상태로 변경했는데 그 사이 고객은 배송지 정보를 변경했다는 것이다.

즉, 애그리거트의 일관성이 깨지는 것이다.

일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두 가지 중 하나를 해야한다.
+ 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
+ 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다.

DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요한데, 대표적으로 `선점 잠금`과 `비선점 잠금`이 있다.

---
### 선점 잠금

선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 하는 방식이다.

![8-2](https://user-images.githubusercontent.com/66859363/208287451-dd9d4f5d-ccc6-40c0-8632-294cab2e2583.png)

위 그림에서 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구하고 있다.

이때 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 `블로킹`된다.

선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.(for update)

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("...")
Optional<Member> findByIdForUpdate(...);
```

선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야한다.

1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

이 순서에 따르면 스레드1은 영원히 B 애그리거트에 대한 선점 잠금을 구할 수 없다.
왜냐하면 스레드2가 B 애그리거트에 대한 잠금을 이미 선점하고 있기 때문이다.

이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야 한다.

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@QueryHints({
    @QueryHint(name = "javax.persistence.lock.timeout", value = "2000")   
})
@Query("...")
Optional<Member> findByIdForUpdate(...);
```

---
### 비선점 잠금
선점 잠금이 강력해 보이긴 하지만 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.

![8 4](https://user-images.githubusercontent.com/66859363/208289869-f5d820d6-3b1f-49c8-b11e-b437401d92d2.png)

위 문제가 발생하면 운영자는 고객이 변경하기 전 배송지 정보를 이용하여 배송 준비를 하게 된다.

이때 필요한 것이 비선점 잠금이다.

비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인한다.

```sql
UPDATE aggtable SET version = version + 1, colx = ?
WHERE aggid = ? AND version = 현재버전
```

![8 5](https://user-images.githubusercontent.com/66859363/208289871-f33e7e83-9c0d-45ff-8540-855b67a3cce3.png)

스레드1과 스레드2는 같은 버전을 갖는 애그리거트를 읽어와 수정한다. 

스레드 1이 먼저 커밋을 시도하는데 이 시점에 버전이 업데이트되고, 스레드2는 수정에 실패한다.

```java
public class Order {
    ...
    
    @Version
    private long version;
    
    ...
}
```

![8 6](https://user-images.githubusercontent.com/66859363/208289872-4da16d24-18b4-47d8-8b95-f345ca107e7f.png)

응용 서비스에 전달할 요청 데이터는 사용자가 전송한 버전 값을 포함한다.

응용 서비스는 전달받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하는 경우에만 기능을 수행한다.

만약 애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하는데 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경된다고 하면, 
JPA는 버전 값을 증가시키지 않을 것이다.

이러한 특징은 애그리거트 관점에서 보면 문제가 된다. 비록 루트 엔티티의 값이 변하지 않았더라도 구성요소 중 
일부 값이 변하면 논리적으로 그 애그리거트는 바뀐 것이다.

```java
@Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT)
@Query("...")
Optional<Member> findById(...);
```

JPA에서는 위와 같이 조회를 실행하면 강제로 버전을 증가시키는 모드를 사용하여 해결할 수 있다.

---
### 오프라인 선점 잠금
더 엄격하게 데이터 충돌을 막고 싶다면 누군가 수정 화면을 보고 있을 때 수정 화면 자체를 실행하지 못하도록 해야 한다.

이때 필요한 것이 오프라인 선점 잠금이다.

단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.

첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. 
잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.

![8 8](https://user-images.githubusercontent.com/66859363/208289873-a25e5f88-5215-423a-8c42-26dc79252f78.png)

```java
오프라인 선점 잠금 구현을 위한 LockManager 인터페이스

public interface LockManager {
    LockId tryLock(...);
    
    void checkLock(...);
    
    void releaseLock(...);
    
    void extendLockExpiration(...);
}
```
